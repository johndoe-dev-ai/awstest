package com.tutorialpoint.kaggle.microsla.lambda;

import com.amazonaws.services.lambda.runtime.Context;
import com.tutorialpoint.kaggle.model.kaggleMicroBatchManControlItem;
import com.tutorialpoint.kaggle.model.kaggleProcessAuditItem;
import com.tutorialpoint.kaggle.service.DynamoDBMicroBatchManControlServiceImpl;
import com.tutorialpoint.kaggle.service.DynamoDBProcessAuditServiceImpl;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import software.amazon.awssdk.enhanced.dynamodb.Key;
import software.amazon.awssdk.enhanced.dynamodb.model.QueryConditional;

import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class MicroBatchSLAMonitoringHandlerImplTest {

    @Mock
    private DynamoDBMicroBatchManControlServiceImpl dynamoDBMicroBatchManControlService;

    @Mock
    private DynamoDBProcessAuditServiceImpl dynamoDBProcessAuditService;

    @Mock
    private Context context;

    @InjectMocks
    private MicroBatchSLAMonitoringHandlerImpl processMonitoringHandler;

    private kaggleMicroBatchManControlItem mockManControlItem;
    private Iterator<kaggleMicroBatchManControlItem> mockIterator;

    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);

        // Initialize the handler (assuming a no-arg constructor)
        processMonitoringHandler = new MicroBatchSLAMonitoringHandlerImpl();

        // Inject mocks into the handler
        processMonitoringHandler.dynamoDBMicroBatchManControlService = dynamoDBMicroBatchManControlService;
        processMonitoringHandler.dynamoDBProcessAuditService = dynamoDBProcessAuditService;

        // Mock the ManControlItem and Iterator for basic cases
        mockManControlItem = mock(kaggleMicroBatchManControlItem.class);
        mockIterator = mock(Iterator.class);

        // Setup mock behavior for ManControlService
        when(dynamoDBMicroBatchManControlService.getAllItems()).thenReturn(mockIterator);
    }

    @Test
    public void testHandleRequest_withValidData_noBreach() {
        // Setup mock behavior for SLA, Current Business Date, etc.
        when(mockIterator.hasNext()).thenReturn(true, false);
        when(mockManControlItem.getSla()).thenReturn(LocalTime.now().plusHours(1).format(DateTimeFormatter.ofPattern("HH:mm")));
        when(mockManControlItem.getCurrentBusinessDate()).thenReturn(LocalDate.now().toString());
        when(mockManControlItem.getDelay()).thenReturn(0L);
        when(mockIterator.next()).thenReturn(mockManControlItem);

        // Execute the handleRequest method
        Map<String, Object> event = new HashMap<>();
        SLAMessage result = processMonitoringHandler.handleRequest(event, context);

        // Verify interactions and assert result
        assertEquals("Updated the date control", result.getMessage());
        verify(dynamoDBMicroBatchManControlService).getAllItems();
        verify(dynamoDBProcessAuditService, never()).putItem(any());
    }

    @Test
    public void testHandleRequest_withSlaBreach() {
        // Setup breach scenario
        when(mockIterator.hasNext()).thenReturn(true, false);
        when(mockManControlItem.getSla()).thenReturn(LocalTime.now().minusMinutes(5).format(DateTimeFormatter.ofPattern("HH:mm")));
        when(mockManControlItem.getCurrentBusinessDate()).thenReturn(LocalDate.now().toString());
        when(mockManControlItem.getDelay()).thenReturn(0L);
        when(mockManControlItem.getJobGroupName()).thenReturn("TestGroup");
        when(mockManControlItem.getJobGroupKey()).thenReturn("TestKey");
        when(mockIterator.next()).thenReturn(mockManControlItem);

        // Mock alreadyLoggedforBreach to return false
        when(dynamoDBProcessAuditService.searchItems(any(), any()))
                .thenReturn(Collections.emptyIterator());

        // Execute handleRequest method
        Map<String, Object> event = new HashMap<>();
        SLAMessage result = processMonitoringHandler.handleRequest(event, context);

        // Assert the SLA breach
        assertEquals("Updated the date control", result.getMessage());
        verify(dynamoDBProcessAuditService).putItem(any());
    }

    @Test
    public void testHandleRequest_alreadyLoggedBreach() {
        // Setup already logged breach scenario
        when(mockIterator.hasNext()).thenReturn(true, false);
        when(mockManControlItem.getSla()).thenReturn(LocalTime.now().minusMinutes(5).format(DateTimeFormatter.ofPattern("HH:mm")));
        when(mockManControlItem.getCurrentBusinessDate()).thenReturn(LocalDate.now().toString());
        when(mockManControlItem.getDelay()).thenReturn(0L);
        when(mockManControlItem.getJobGroupName()).thenReturn("TestGroup");
        when(mockManControlItem.getJobGroupKey()).thenReturn("TestKey");
        when(mockIterator.next()).thenReturn(mockManControlItem);

        // Mock alreadyLoggedforBreach to return true
        kaggleProcessAuditItem breachAuditItem = new kaggleProcessAuditItem();
        Iterator<kaggleProcessAuditItem> breachIterator = Arrays.asList(breachAuditItem).iterator();
        when(dynamoDBProcessAuditService.searchItems(any(), any()))
                .thenReturn(breachIterator);

        // Execute the handleRequest method
        Map<String, Object> event = new HashMap<>();
        SLAMessage result = processMonitoringHandler.handleRequest(event, context);

        // Verify no logging of breach since it's already logged
        verify(dynamoDBProcessAuditService, never()).putItem(any());
        assertEquals("Updated the date control", result.getMessage());
    }

    @Test
    public void testHandleRequest_withException() {
        // Setup mock to throw an exception
        when(mockIterator.hasNext()).thenThrow(new RuntimeException("Test exception"));

        // Execute the handleRequest method
        Map<String, Object> event = new HashMap<>();
        SLAMessage result = processMonitoringHandler.handleRequest(event, context);

        // Assert the failure scenario
        assertEquals("Couldn't update the date control", result.getMessage());
    }

    @Test
    public void testAlreadyLoggedforBreach_notLogged() {
        // Setup
        kaggleMicroBatchManControlItem manControlItem = new kaggleMicroBatchManControlItem();
        manControlItem.setJobGroupName("TestGroup");
        manControlItem.setJobGroupKey("TestKey");

        LocalDate currentDate = LocalDate.now();

        when(dynamoDBProcessAuditService.searchItems(any(), any()))
                .thenReturn(Collections.emptyIterator());

        // Execute
        boolean result = processMonitoringHandler.alreadyLoggedforBreach(manControlItem, currentDate);

        // Assert
        assertFalse(result);
    }

    @Test
    public void testAlreadyLoggedforBreach_alreadyLogged() {
        // Setup
        kaggleMicroBatchManControlItem manControlItem = new kaggleMicroBatchManControlItem();
        manControlItem.setJobGroupName("TestGroup");
        manControlItem.setJobGroupKey("TestKey");

        LocalDate currentDate = LocalDate.now();

        kaggleProcessAuditItem breachAuditItem = new kaggleProcessAuditItem();
        Iterator<kaggleProcessAuditItem> iterator = Arrays.asList(breachAuditItem).iterator();

        when(dynamoDBProcessAuditService.searchItems(any(), any()))
                .thenReturn(iterator);

        // Execute
        boolean result = processMonitoringHandler.alreadyLoggedforBreach(manControlItem, currentDate);

        // Assert
        assertTrue(result);
    }

    @Test
    public void testLogProcess() {
        // Setup
        kaggleMicroBatchManControlItem manControlItem = new kaggleMicroBatchManControlItem();
        manControlItem.setJobGroupName("TestGroup");
        manControlItem.setJobGroupKey("TestKey");
        manControlItem.setSla("14:00");

        LocalDate currentDate = LocalDate.now();

        // Execute
        processMonitoringHandler.logProcess(manControlItem, currentDate);

        // Assert
        ArgumentCaptor<kaggleProcessAuditItem> captor = ArgumentCaptor.forClass(kaggleProcessAuditItem.class);
        verify(dynamoDBProcessAuditService).putItem(captor.capture());

        kaggleProcessAuditItem loggedItem = captor.getValue();
        assertEquals("TestGroup", loggedItem.getJobGroupName());
        assertEquals("TestKey/" + currentDate, loggedItem.getJobGroupKey());
        assertFalse(loggedItem.isIncidentRaised());
    }

    @Test
    public void testHandleRequest_withNullSla() {
        when(mockIterator.hasNext()).thenReturn(true, false);
        when(mockManControlItem.getSla()).thenReturn(null);
        when(mockManControlItem.getJobGroupName()).thenReturn("TestGroup");
        when(mockManControlItem.getJobGroupKey()).thenReturn("TestKey");
        when(mockIterator.next()).thenReturn(mockManControlItem);

        Map<String, Object> event = new HashMap<>();
        SLAMessage result = processMonitoringHandler.handleRequest(event, context);

        assertEquals("Updated the date control", result.getMessage());
        // Verify that no breach is logged
        verify(dynamoDBProcessAuditService, never()).putItem(any());
    }

    @Test
    public void testHandleRequest_withEmptySla() {
        when(mockIterator.hasNext()).thenReturn(true, false);
        when(mockManControlItem.getSla()).thenReturn("   ");
        when(mockManControlItem.getJobGroupName()).thenReturn("TestGroup");
        when(mockManControlItem.getJobGroupKey()).thenReturn("TestKey");
        when(mockIterator.next()).thenReturn(mockManControlItem);

        Map<String, Object> event = new HashMap<>();
        SLAMessage result = processMonitoringHandler.handleRequest(event, context);

        assertEquals("Updated the date control", result.getMessage());
        verify(dynamoDBProcessAuditService, never()).putItem(any());
    }

    @Test
    public void testHandleRequest_withInvalidSlaFormat() {
        when(mockIterator.hasNext()).thenReturn(true, false);
        when(mockManControlItem.getSla()).thenReturn("invalid-time");
        when(mockManControlItem.getJobGroupName()).thenReturn("TestGroup");
        when(mockManControlItem.getJobGroupKey()).thenReturn("TestKey");
        when(mockIterator.next()).thenReturn(mockManControlItem);

        Map<String, Object> event = new HashMap<>();
        SLAMessage result = processMonitoringHandler.handleRequest(event, context);

        // Since parsing will fail, an exception might be thrown
        // Verify that the exception is handled gracefully
        assertEquals("Couldn't update the date control", result.getMessage());
    }

    @Test
    public void testHandleRequest_withDifferentTimeZone() {
        when(mockIterator.hasNext()).thenReturn(true, false);
        when(mockManControlItem.getSla()).thenReturn("14:00");
        when(mockManControlItem.getCurrentBusinessDate()).thenReturn(LocalDate.now().toString());
        when(mockManControlItem.getDelay()).thenReturn(0L);
        when(mockIterator.next()).thenReturn(mockManControlItem);

        // Change the system default time zone temporarily
        ZoneId originalZoneId = ZoneId.systemDefault();
        try {
            ZoneId.setDefault(ZoneId.of("Asia/Tokyo"));

            Map<String, Object> event = new HashMap<>();
            SLAMessage result = processMonitoringHandler.handleRequest(event, context);

            assertEquals("Updated the date control", result.getMessage());
            // Additional assertions as needed
        } finally {
            // Restore the original time zone
            ZoneId.setDefault(originalZoneId);
        }
    }

    @Test
    public void testHandleRequest_serviceException() {
        when(dynamoDBMicroBatchManControlService.getAllItems())
                .thenThrow(new RuntimeException("Service exception"));

        Map<String, Object> event = new HashMap<>();
        SLAMessage result = processMonitoringHandler.handleRequest(event, context);

        assertEquals("Couldn't update the date control", result.getMessage());
    }

    @Test
    public void testHandleRequest_withMultipleDataItems() {
        kaggleMicroBatchManControlItem item1 = mock(kaggleMicroBatchManControlItem.class);
        kaggleMicroBatchManControlItem item2 = mock(kaggleMicroBatchManControlItem.class);

        when(item1.getSla()).thenReturn(LocalTime.now().plusHours(1).format(DateTimeFormatter.ofPattern("HH:mm")));
        when(item1.getCurrentBusinessDate()).thenReturn(LocalDate.now().toString());
        when(item1.getDelay()).thenReturn(0L);

        when(item2.getSla()).thenReturn(LocalTime.now().minusHours(1).format(DateTimeFormatter.ofPattern("HH:mm")));
        when(item2.getCurrentBusinessDate()).thenReturn(LocalDate.now().toString());
        when(item2.getJobGroupName()).thenReturn("TestGroup2");
        when(item2.getJobGroupKey()).thenReturn("TestKey2");
        when(item2.getDelay()).thenReturn(0L);

        Iterator<kaggleMicroBatchManControlItem> iterator = Arrays.asList(item1, item2).iterator();
        when(dynamoDBMicroBatchManControlService.getAllItems()).thenReturn(iterator);

        // Mock alreadyLoggedforBreach for item2 to return false
        when(dynamoDBProcessAuditService.searchItems(any(), any()))
                .thenReturn(Collections.emptyIterator());

        Map<String, Object> event = new HashMap<>();
        SLAMessage result = processMonitoringHandler.handleRequest(event, context);

        assertEquals("Updated the date control", result.getMessage());
        // Verify that breach is logged for item2
        verify(dynamoDBProcessAuditService).putItem(any());
    }
}
