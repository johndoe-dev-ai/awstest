 Understood. I'll modify the function to save the generated metadata to a file named after the input CSV file, with "_metadata.txt" appended. Here's the updated version:

```python
import csv
import json
from typing import List, Dict, Any
from datetime import datetime
import re
import os

def generate_and_save_metadata(csv_file_path: str) -> None:
    metadata = generate_metadata_from_csv(csv_file_path)
    
    # Generate the metadata file name
    base_name = os.path.splitext(csv_file_path)[0]
    metadata_file_path = f"{base_name}_metadata.txt"
    
    # Save metadata to file
    with open(metadata_file_path, 'w') as f:
        json.dump(metadata, f, indent=2)
    
    print(f"Metadata saved to {metadata_file_path}")

def generate_metadata_from_csv(csv_file_path: str) -> List[Dict[str, Any]]:
    metadata = []
    
    with open(csv_file_path, 'r', newline='') as csvfile:
        csv_reader = csv.reader(csvfile)
        
        # Extract header and convert to lowercase
        header = [col.lower() for col in next(csv_reader)]
        
        # Read the first data row to infer data types
        first_data_row = next(csv_reader)
        
        for col_name, value in zip(header, first_data_row):
            data_type = infer_data_type(value)
            
            metadata_item = {
                'name': col_name,
                'description': '',  # Left blank as per instructions
                'dataType': data_type
            }
            metadata.append(metadata_item)
    
    return metadata

def infer_data_type(value: str) -> str:
    # Check for empty value
    if not value.strip():
        return 'string'  # Default to string for empty values
    
    # Check for boolean
    if value.lower() in ('true', 'false'):
        return 'boolean'
    
    # Check for integer
    if re.match(r'^-?\d+$', value):
        return 'integer'
    
    # Check for float/double
    if re.match(r'^-?\d+\.\d+$', value):
        return 'double'
    
    # Check for date
    try:
        datetime.strptime(value, '%Y-%m-%d')
        return 'date'
    except ValueError:
        pass
    
    # Check for timestamp/datetime
    datetime_formats = [
        '%Y-%m-%d %H:%M:%S',
        '%Y-%m-%dT%H:%M:%S',
        '%Y-%m-%d %H:%M:%S.%f',
        '%Y-%m-%dT%H:%M:%S.%f'
    ]
    for fmt in datetime_formats:
        try:
            datetime.strptime(value, fmt)
            return 'timestamp'
        except ValueError:
            continue
    
    # If none of the above, assume it's a string
    return 'string'

# Example usage
if __name__ == "__main__":
    csv_file_path = 'your_csv_file.csv'
    generate_and_save_metadata(csv_file_path)
```

Key changes in this version:

1. Added a new function `generate_and_save_metadata` that:
   - Calls `generate_metadata_from_csv` to create the metadata
   - Constructs the output file name by appending "_metadata.txt" to the original CSV file name (without extension)
   - Saves the metadata as JSON to the constructed file name

2. The main execution now calls `generate_and_save_metadata` instead of just generating and printing the metadata.

3. Added a print statement to inform the user where the metadata file has been saved.

To use this script:

1. Save it as a Python file (e.g., `csv_metadata_generator.py`)
2. Run it from the command line, providing the path to your CSV file:

   ```
   python csv_metadata_generator.py
   ```

   (Make sure to replace 'your_csv_file.csv' in the script with the actual CSV file path, or modify the script to accept command-line arguments)

This script will generate the metadata and save it to a file named after your CSV file with "_metadata.txt" appended. For example, if your CSV file is named "data.csv", the metadata will be saved to "data_metadata.txt" in the same directory.
